# 2018-04-17

## 단방향 해시 함수

\* 수학적인 연산을 통해 원본 메시지를 변환하여 암호화된 메시지인 다이제스트\(digest\)를 생성

\* 암호화된 메시지로는 원본 메시지를 구할 수 없어 단방향이라 말함

\* 대부분의 해시 함수는 입력 값의 일부가 변경 되었을 때 다이제스트가 완전히 달라지도록 설계 됨 \(avalanche 효과\)



\#\# 단방향 해시 함수의 문제점



\#\#\# 인식 가능성\(recognizability\)

\* 동일한 메시지가 항상 동일한 다이제스트를 갖을 경우, 공격자가 다이제스트를 많이 확보한 후 탈취한 다이제스트와 비교해 원본 메시지를 찾아낼 수 있음

\* 레인보우 테이블: 다이제스트 목록

\* 레인보우 공격: 레인보우 테이블을 활용해 원본 메시지를 찾아내는 공격



\#\#\# 속도

\* 해시 함수는 원래 짧은 시간에 데이터를 검색하기 위해 설계된 것

\* 해시 함수의 빠른 처리 속도로 오히려 공격자가 빠른 속도로 레인보우 공격을 할 수 있게 됨



\#\# 단방향 해시 함수 보완



\#\#\# 솔팅\(Salting\)

\* 솔트\(salt\)는 다이제스트 생성시 추가되는 바이트 단위의 임의의 문자열

\* 원본 메시지에 문자열을 추가하여 다이제스트를 생성하는 것

\* 공격자가 원본 메시지의 다이제스트를 알아내도 솔팅된 다이제스트를 대상으로 패스워드 일치 여부를 확인할 수 없음



\#\#\# 키 스트레칭\(key stretching\)

\* 원본의 다이제스트를 생성하고, 생성된 다이제스트의 다이제스트를 생성하면서 다이제스트를 반복하여 생성하는 방법

\* 패스워드를 추측하는데 많은 시간이 소요되도록 하여 공격을 억제



\#\# Adaptive Key Derivation Functions

\* 다이제스트를 생성시 솔팅과 키 스트레칭을 반복하며 입력 값을 추가하여 공격자가 쉽게 다이제스트를 유추할 수 없도록 보안의 강도 선택 가능한 함수

\* GPU 등의 장비를 이용한 병렬화를 어렵게 함



\#\#\# 주요 Key Derivation Function



\#\#\#\# PBKDF2

\* Passsword-Based Key Derivation Function

\* DIGEST = PBKDF2\(PRF, Password, Salt, c, DLen\)  

   \* PRF: 난수

   \* Password: 비밀번호

   \* Salt: 암호학 솔트

   \* c: 원하는 반복 수

   \* Dlen: 원하는 다이제스트 길이

\* 미국표준기술연구소에서 승인된 알고리즘



\#\#\#\# bcrypt

\* 패스워드 저장을 목적으로 설계된 암호화 함수



\#\#\#\# scrypt

\* 다이제스트를 생성할 때 메모리 오버헤드를 갖도록 설계되어 억지공격기법을 방어

\* PBKDF2, bcrypt에 비해 안전하고 경쟁력 있다고 평가

\* DIGEST = scrypt\(Password, Salt, N, r, p, DLen\)  

   \* Password: 비밀번호

   \* Salt: 암호학 솔트

   \* N: CPU 비용

   \* r : 메모리 비용

   \* p: 병렬화

   \* Dlen: 원하는 다이제스트 길이



\#\# 결론

\* MD5, SHA-1, SHA-256, SHA-512 등의 해시 함수는 메시지 인증과 무결성 체크를 위한 것이다. 

\* 이것을 패스워드 인증을 위해 사용하면 앞에서 말한 인식 가능성과 빠른 처리 속도에 기인하는 취약점이 존재한다.

\* 이를 해결하기 위해서는 위에서 언급한 key derivation function을 사용하는 것을 권장한다.

\* ISO-27001의 보안 규정을 준수하고, 서드파티의 라이브러리에 의존하지 않으면서 사용자 패스워드의 다이제스트를 생성하려면 PBKDF2-HMAC-SHA-256/SHA-512을 사용하면 된다.











